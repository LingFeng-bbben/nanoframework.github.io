<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>

  <head>
    <meta charset="utf-8">
      <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
      <title>Class InMemoryRandomAccessStream
 | .NET nanoFramework Documentation </title>
      <meta name="viewport" content="width=device-width">
      <meta name="title" content="Class InMemoryRandomAccessStream
 | .NET nanoFramework Documentation ">
    

      <link rel="apple-touch-icon" sizes="180x180" href="../favicons/apple-touch-icon.png">
      <link rel="icon" type="image/png" sizes="32x32" href="../favicons/favicon-32x32.png">
      <link rel="icon" type="image/png" sizes="16x16" href="../favicons/favicon-16x16.png">
      <link rel="manifest" href="../favicons/site.webmanifest">
      <link rel="shortcut icon" type="image/x-icon" href="../favicon.ico">
      <link rel="mask-icon" href="../favicons/safari-pinned-tab.svg" color="#179b88">
      <meta name="msapplication-config" content="../favicons/browserconfig.xml">
      <meta name="msapplication-TileColor" content="#222222">
      <meta name="theme-color" content="#222222">

      <link rel="stylesheet" href="../styles/docfx.vendor.min.css">
      <link rel="stylesheet" href="../styles/docfx.css">
      <link rel="stylesheet" href="../styles/main.css">
      <meta property="docfx:navrel" content="../toc.html">
      <meta property="docfx:tocrel" content="toc.html">
    
    <meta property="docfx:rel" content="../">
    
  </head>  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>

        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>

              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>

        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">

        <div id="search-results">
          <div class="search-list">Search Results for <span></span></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination" data-first="First" data-prev="Previous" data-next="Next" data-last="Last"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">

        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="Windows.Storage.Streams.InMemoryRandomAccessStream">



  <h1 id="Windows_Storage_Streams_InMemoryRandomAccessStream" data-uid="Windows.Storage.Streams.InMemoryRandomAccessStream" class="text-break">Class InMemoryRandomAccessStream
</h1>
  <div class="markdown level0 summary"><p>Provides random access of data in input and output streams that are stored in memory instead of on disk.</p>
</div>
  <div class="markdown level0 conceptual"></div>
  <div class="inheritance">
    <h5>Inheritance</h5>
    <div class="level0"><a class="xref" href="System.Object.html">object</a></div>
    <div class="level1"><a class="xref" href="System.MarshalByRefObject.html">MarshalByRefObject</a></div>
    <div class="level2"><span class="xref">InMemoryRandomAccessStream</span></div>
  </div>
  <div class="implements">
    <h5>Implements</h5>
    <div><a class="xref" href="Windows.Storage.Streams.IRandomAccessStream.html">IRandomAccessStream</a></div>
    <div><a class="xref" href="System.IDisposable.html">IDisposable</a></div>
    <div><a class="xref" href="Windows.Storage.Streams.IInputStream.html">IInputStream</a></div>
    <div><a class="xref" href="Windows.Storage.Streams.IOutputStream.html">IOutputStream</a></div>
  </div>
  <div class="inheritedMembers">
    <h5>Inherited Members</h5>
    <div>
      <a class="xref" href="System.Object.html#System_Object_ToString">object.ToString()</a>
    </div>
    <div>
      <a class="xref" href="System.Object.html#System_Object_Equals_System_Object_">object.Equals(object)</a>
    </div>
    <div>
      <a class="xref" href="System.Object.html#System_Object_Equals_System_Object_System_Object_">object.Equals(object, object)</a>
    </div>
    <div>
      <a class="xref" href="System.Object.html#System_Object_ReferenceEquals_System_Object_System_Object_">object.ReferenceEquals(object, object)</a>
    </div>
    <div>
      <a class="xref" href="System.Object.html#System_Object_GetHashCode">object.GetHashCode()</a>
    </div>
    <div>
      <a class="xref" href="System.Object.html#System_Object_GetType">object.GetType()</a>
    </div>
  </div>
  <h6><strong>Namespace</strong>: <a class="xref" href="Windows.html">Windows</a>.<a class="xref" href="Windows.Storage.html">Storage</a>.<a class="xref" href="Windows.Storage.Streams.html">Streams</a></h6>
  <h6><strong>Assembly</strong>: Windows.Storage.Streams.dll</h6>
  <h5 id="Windows_Storage_Streams_InMemoryRandomAccessStream_syntax">Syntax</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public sealed class InMemoryRandomAccessStream : MarshalByRefObject, IRandomAccessStream, IDisposable, IInputStream, IOutputStream</code></pre>
  </div>
  <h3 id="constructors">Constructors
</h3>


  <a id="Windows_Storage_Streams_InMemoryRandomAccessStream__ctor_" data-uid="Windows.Storage.Streams.InMemoryRandomAccessStream.#ctor*"></a>
  <h4 id="Windows_Storage_Streams_InMemoryRandomAccessStream__ctor" data-uid="Windows.Storage.Streams.InMemoryRandomAccessStream.#ctor">InMemoryRandomAccessStream()</h4>
  <div class="markdown level1 summary"><p>Creates a new instance of the InMemoryRandomAccessStream class.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="declaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public InMemoryRandomAccessStream()</code></pre>
  </div>
  <h3 id="properties">Properties
</h3>


  <a id="Windows_Storage_Streams_InMemoryRandomAccessStream_CanRead_" data-uid="Windows.Storage.Streams.InMemoryRandomAccessStream.CanRead*"></a>
  <h4 id="Windows_Storage_Streams_InMemoryRandomAccessStream_CanRead" data-uid="Windows.Storage.Streams.InMemoryRandomAccessStream.CanRead">CanRead</h4>
  <div class="markdown level1 summary"><p>Gets a value that indicates whether the stream can be read from.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="declaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool CanRead { get; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="System.Boolean.html">bool</a></td>
        <td><p>True if the stream can be read from. Otherwise, false.</p>
</td>
      </tr>
    </tbody>
  </table>


  <a id="Windows_Storage_Streams_InMemoryRandomAccessStream_CanWrite_" data-uid="Windows.Storage.Streams.InMemoryRandomAccessStream.CanWrite*"></a>
  <h4 id="Windows_Storage_Streams_InMemoryRandomAccessStream_CanWrite" data-uid="Windows.Storage.Streams.InMemoryRandomAccessStream.CanWrite">CanWrite</h4>
  <div class="markdown level1 summary"><p>Gets a value that indicates whether the stream can be written to.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="declaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool CanWrite { get; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="System.Boolean.html">bool</a></td>
        <td><p>True if the stream can be written to. Otherwise, false.</p>
</td>
      </tr>
    </tbody>
  </table>


  <a id="Windows_Storage_Streams_InMemoryRandomAccessStream_Length_" data-uid="Windows.Storage.Streams.InMemoryRandomAccessStream.Length*"></a>
  <h4 id="Windows_Storage_Streams_InMemoryRandomAccessStream_Length" data-uid="Windows.Storage.Streams.InMemoryRandomAccessStream.Length">Length</h4>
  <div class="markdown level1 summary"><p>Gets the number of bytes currently in use in the buffer.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="declaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ulong Length { get; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="System.UInt64.html">ulong</a></td>
        <td><p>he number of bytes currently in use in the buffer, which is less than or equal to the capacity of the buffer.</p>
</td>
      </tr>
    </tbody>
  </table>


  <a id="Windows_Storage_Streams_InMemoryRandomAccessStream_Position_" data-uid="Windows.Storage.Streams.InMemoryRandomAccessStream.Position*"></a>
  <h4 id="Windows_Storage_Streams_InMemoryRandomAccessStream_Position" data-uid="Windows.Storage.Streams.InMemoryRandomAccessStream.Position">Position</h4>
  <div class="markdown level1 summary"><p>Gets the byte offset of the stream.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="declaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ulong Position { get; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="System.UInt64.html">ulong</a></td>
        <td><p>The number of bytes from the start of the stream.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Windows_Storage_Streams_InMemoryRandomAccessStream_Position_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The initial offset of a IRandomAccessStream is 0.
This offset is affected by both <a class="xref" href="Windows.Storage.Streams.IInputStream.html">IInputStream</a> and <a class="xref" href="Windows.Storage.Streams.IOutputStream.html">IOutputStream</a> operations.</p>
</div>


  <a id="Windows_Storage_Streams_InMemoryRandomAccessStream_Size_" data-uid="Windows.Storage.Streams.InMemoryRandomAccessStream.Size*"></a>
  <h4 id="Windows_Storage_Streams_InMemoryRandomAccessStream_Size" data-uid="Windows.Storage.Streams.InMemoryRandomAccessStream.Size">Size</h4>
  <div class="markdown level1 summary"><p>Gets or sets the size of the random access stream.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="declaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ulong Size { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="System.UInt64.html">ulong</a></td>
        <td><p>The size of the stream.</p>
</td>
      </tr>
    </tbody>
  </table>


  <a id="Windows_Storage_Streams_InMemoryRandomAccessStream_UnstoredBufferLength_" data-uid="Windows.Storage.Streams.InMemoryRandomAccessStream.UnstoredBufferLength*"></a>
  <h4 id="Windows_Storage_Streams_InMemoryRandomAccessStream_UnstoredBufferLength" data-uid="Windows.Storage.Streams.InMemoryRandomAccessStream.UnstoredBufferLength">UnstoredBufferLength</h4>
  <div class="markdown level1 summary"><p>Gets the size of the buffer that has not been used.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="declaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public uint UnstoredBufferLength { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="System.UInt32.html">uint</a></td>
        <td><p>The available buffer length, in bytes.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h3 id="methods">Methods
</h3>


  <a id="Windows_Storage_Streams_InMemoryRandomAccessStream_Dispose_" data-uid="Windows.Storage.Streams.InMemoryRandomAccessStream.Dispose*"></a>
  <h4 id="Windows_Storage_Streams_InMemoryRandomAccessStream_Dispose" data-uid="Windows.Storage.Streams.InMemoryRandomAccessStream.Dispose">Dispose()</h4>
  <div class="markdown level1 summary"><p>Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="declaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void Dispose()</code></pre>
  </div>


  <a id="Windows_Storage_Streams_InMemoryRandomAccessStream_Flush_" data-uid="Windows.Storage.Streams.InMemoryRandomAccessStream.Flush*"></a>
  <h4 id="Windows_Storage_Streams_InMemoryRandomAccessStream_Flush" data-uid="Windows.Storage.Streams.InMemoryRandomAccessStream.Flush">Flush()</h4>
  <div class="markdown level1 summary"><p>Flushes data in a sequential stream.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="declaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool Flush()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="System.Boolean.html">bool</a></td>
        <td><p>The stream flush operation.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Windows_Storage_Streams_InMemoryRandomAccessStream_Flush_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The Flush method may produce latencies and does not always guarantee durable and coherent storage of data. It's generally recommended to avoid this method if possible.
This method is specific to nanoFramework. The equivalent method in the UWP API is: FlushAsync.</p>
</div>


  <a id="Windows_Storage_Streams_InMemoryRandomAccessStream_Read_" data-uid="Windows.Storage.Streams.InMemoryRandomAccessStream.Read*"></a>
  <h4 id="Windows_Storage_Streams_InMemoryRandomAccessStream_Read_Windows_Storage_Streams_IBuffer_System_UInt32_Windows_Storage_Streams_InputStreamOptions_" data-uid="Windows.Storage.Streams.InMemoryRandomAccessStream.Read(Windows.Storage.Streams.IBuffer,System.UInt32,Windows.Storage.Streams.InputStreamOptions)">Read(IBuffer, uint, InputStreamOptions)</h4>
  <div class="markdown level1 summary"><p>Reads data from the stream.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="declaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public uint Read(IBuffer buffer, uint count, InputStreamOptions options)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Windows.Storage.Streams.IBuffer.html">IBuffer</a></td>
        <td><span class="parametername">buffer</span></td>
        <td><p>A buffer that is used to return the array of bytes that are read. The return value contains the buffer that holds the results.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="System.UInt32.html">uint</a></td>
        <td><span class="parametername">count</span></td>
        <td><p>The number of bytes to read that is less than or equal to the Capacity value.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="Windows.Storage.Streams.InputStreamOptions.html">InputStreamOptions</a></td>
        <td><span class="parametername">options</span></td>
        <td><p>Specifies the type of the asynchronous read operation.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="System.UInt32.html">uint</a></td>
        <td><p>The number of bytes that were actually read.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Windows_Storage_Streams_InMemoryRandomAccessStream_Read_Windows_Storage_Streams_IBuffer_System_UInt32_Windows_Storage_Streams_InputStreamOptions__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This method is specific to nanoFramework. The equivalent method in the UWP API is: ReadAsync(IBuffer buffer, UInt32 count, InputStreamOptions options).</p>
</div>


  <a id="Windows_Storage_Streams_InMemoryRandomAccessStream_Seek_" data-uid="Windows.Storage.Streams.InMemoryRandomAccessStream.Seek*"></a>
  <h4 id="Windows_Storage_Streams_InMemoryRandomAccessStream_Seek_System_UInt64_" data-uid="Windows.Storage.Streams.InMemoryRandomAccessStream.Seek(System.UInt64)">Seek(ulong)</h4>
  <div class="markdown level1 summary"><p>Sets the position of the stream to the specified value.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="declaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void Seek(ulong position)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="System.UInt64.html">ulong</a></td>
        <td><span class="parametername">position</span></td>
        <td><p>The new position of the stream.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Windows_Storage_Streams_InMemoryRandomAccessStream_Seek_System_UInt64__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Warning! This method does not check the position to make sure the value is valid for the stream. If the position is invalid for the stream, the ReadAsync and WriteAsync methods will return an error if you call them.</p>
</div>


  <a id="Windows_Storage_Streams_InMemoryRandomAccessStream_Store_" data-uid="Windows.Storage.Streams.InMemoryRandomAccessStream.Store*"></a>
  <h4 id="Windows_Storage_Streams_InMemoryRandomAccessStream_Store" data-uid="Windows.Storage.Streams.InMemoryRandomAccessStream.Store">Store()</h4>
  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="declaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public uint Store()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="System.UInt32.html">uint</a></td>
        <td></td>
      </tr>
    </tbody>
  </table>


  <a id="Windows_Storage_Streams_InMemoryRandomAccessStream_Write_" data-uid="Windows.Storage.Streams.InMemoryRandomAccessStream.Write*"></a>
  <h4 id="Windows_Storage_Streams_InMemoryRandomAccessStream_Write_System_Byte___" data-uid="Windows.Storage.Streams.InMemoryRandomAccessStream.Write(System.Byte[])">Write(byte[])</h4>
  <div class="markdown level1 summary"><p>Writes data in a sequential stream.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="declaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void Write(byte[] buffer)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="System.Byte.html">byte</a>[]</td>
        <td><span class="parametername">buffer</span></td>
        <td><p>A buffer that contains the data to be written.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Windows_Storage_Streams_InMemoryRandomAccessStream_Write_System_Byte____remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This method is specific to nanoFramework. The equivalent method in the UWP API is: WriteAsync.</p>
</div>
  <h3 id="implements">Implements</h3>
  <div>
      <a class="xref" href="Windows.Storage.Streams.IRandomAccessStream.html">IRandomAccessStream</a>
  </div>
  <div>
      <a class="xref" href="System.IDisposable.html">IDisposable</a>
  </div>
  <div>
      <a class="xref" href="Windows.Storage.Streams.IInputStream.html">IInputStream</a>
  </div>
  <div>
      <a class="xref" href="Windows.Storage.Streams.IOutputStream.html">IOutputStream</a>
  </div>
  <h3 id="extensionmethods">Extension Methods</h3>
  <div>
      <a class="xref" href="nanoFramework.Logging.LogDispatcher.html#nanoFramework_Logging_LogDispatcher_GetCurrentClassLogger_System_Object_">LogDispatcher.GetCurrentClassLogger(object)</a>
  </div>
  <div>
      <a class="xref" href="nanoFramework.Logging.LogDispatcher.html#nanoFramework_Logging_LogDispatcher_GetCurrentClassLogger_System_Object_">LogDispatcher.GetCurrentClassLogger(object)</a>
  </div>
  <div>
      <a class="xref" href="nanoFramework.Logging.LogDispatcher.html#nanoFramework_Logging_LogDispatcher_GetCurrentClassLogger_System_Object_">LogDispatcher.GetCurrentClassLogger(object)</a>
  </div>
  <div>
      <a class="xref" href="nanoFramework.Logging.LogDispatcher.html#nanoFramework_Logging_LogDispatcher_GetCurrentClassLogger_System_Object_">LogDispatcher.GetCurrentClassLogger(object)</a>
  </div>
  <div>
      <a class="xref" href="nanoFramework.Logging.LogDispatcher.html#nanoFramework_Logging_LogDispatcher_GetCurrentClassLogger_System_Object_">LogDispatcher.GetCurrentClassLogger(object)</a>
  </div>
  <div>
      <a class="xref" href="nanoFramework.Logging.LogDispatcher.html#nanoFramework_Logging_LogDispatcher_GetCurrentClassLogger_System_Object_">LogDispatcher.GetCurrentClassLogger(object)</a>
  </div>
  <div>
      <a class="xref" href="nanoFramework.Logging.LogDispatcher.html#nanoFramework_Logging_LogDispatcher_GetCurrentClassLogger_System_Object_">LogDispatcher.GetCurrentClassLogger(object)</a>
  </div>
  <div>
      <a class="xref" href="nanoFramework.Logging.LogDispatcher.html#nanoFramework_Logging_LogDispatcher_GetCurrentClassLogger_System_Object_">LogDispatcher.GetCurrentClassLogger(object)</a>
  </div>
  <div>
      <a class="xref" href="nanoFramework.Logging.LogDispatcher.html#nanoFramework_Logging_LogDispatcher_GetCurrentClassLogger_System_Object_">LogDispatcher.GetCurrentClassLogger(object)</a>
  </div>
  <div>
      <a class="xref" href="nanoFramework.Logging.LogDispatcher.html#nanoFramework_Logging_LogDispatcher_GetCurrentClassLogger_System_Object_">LogDispatcher.GetCurrentClassLogger(object)</a>
  </div>

</article>
          </div>

          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In this article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>

      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
      
      <span>Copyright © 2023 nanoFramework Contributors<br>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>    </div>

    <script type="text/javascript" src="../styles/docfx.vendor.min.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
